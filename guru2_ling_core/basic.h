#pragma once

/**
 * 类有三种用户:
 1. 普通用户
	使用类的对象，只能访问类的公有(接口)成员
 2. 类的实现者
	编写类的成员和友元代码，既能访问类的公有部分，也能访问类的私有部分(实现)
 3. 派生类
	可以使用基类的保护部分，无法访问私有部分
 三种用户可以对应类的三种可访问性
 */

/**
 * 类的作用域
 类的定义体内也就是类的作用域，派生类的作用域嵌套在基类的作用域之内，名称的查找从自己的作用域开始，逐层向外
 类模板在自己的作用域内不需要模板参数信息。在类模板外，直到遇到类名才表示进入类的作用域。
 */

/**
 * 如何编写异常安全的代码?
 1. 将资源管理功能独立出来(RAII)
 2. “更新临时对象然后再交换”
 3. 析构函数不要抛出异常
 */

/**
 * 
 1. +运算符实现为非成员函数，+=实现为成员函数，前者调用后者，前者返回自身，后者返回结果临时对象
 2. 对于返回临时对象的函数(成员或非成员函数)，返回类型为const
 3. 对于返回引用的成员函数，定义const和非const两个版本
 4. << >> 运算符不一定是类的友元，可以定义一个成员函数(可以虚拟)，由非成员运算符调用
 5. ++前置和后置版本，后置调用前置实现。
 */

class X {};
void f(const X&);

class X1 {
public:
	void f() const;
};

/**
 * 上面的两个类的接口定义本质上是一样的(成员函数可以访问类私有成员数据，自由函数必须是友元才可以)
 (所以成员函数与类的关系要强于非成员函数与类的关系)
 对于类X来说，如果所有函数，包括自由函数，能够满足以下条件:
 1. 使用了X
 2. 与X同时被定义(同一名字空间)
 那些这些函数在逻辑上都是X的一部分，构成X接口的一部分
 */